# File Lock How-to on Java Environment


# Network File System - NFS 

 これが本ファイルでの肝である。

 ローカルのファイルシステムに対して、リモートのファイルシステムをマウントすることがある。この代表例が Network File System - NFS である。
 若い方は、あまりご存じではないかもしれないが、大学のネットワーク等で少数のファイルサーバに多数のクライアントホストが /home をマウントして運用されていた。
 （これは、ディスクが自体が高価だったことやバックアップ等のストレージのサポートのためのリソース（テープやそれを扱うオペレータ）も高価だったことが理由としてあげられる。
 一人10Mのストレージでも、1000人集まれば 10T のディスクが必要になる。50台のホストを順次バックアップするのも大変な手間である）

```
/usr/bin と /bin が分離しているのは、 /usr をNFSでマウントできるようにするためであった。最近は、ディスクが大きいので意義を失ってしまったが。
```

 ところで、NFS はファイルロックにおいて非常に問題が大きい存在であった。1990年代においてはまともにロックできないし、しないと有名であった。
 NFSにはバージョンがあり、NFSv2 v3 v4 あたりが使われている。

 まずopen(2)のマニュアルから、 O_EXCL の部分を引用する。

```
      O_EXCL この呼び出しでファイルが作成されることを保証する。このフラグが O_CREAT と 一緒に指定さ
              れ、 pathname のファイルが既に存在した場合、 open() は失敗 する。

              これら二つのフラグが指定された際、シンボリックリンクは辿られない。  pathname  がシンボ
              リックリンクの場合、 シンボリックリンクがどこを指しているかに関わらず open()  は失敗す
              る。

              一般的には、 O_CREAT を指定せずに O_EXCL を使用した場合の O_EXCL  の動作は規定されてい
              ない。  これには一つ例外があり、Linux 2.6 以降では、 pathname がブロックデバイスを参照
              している場合、 O_CREAT なしで O_EXCL を使用することができる。 システムがそのブロックデ
              バイスを使用中の場合  (例えば、 マウントされているなど)、 open() はエラー EBUSY で失敗
              する。

              NFS では、 O_EXCL は、Linux 2.6  以降で  NFSv3  以降を使っている場合でのみサポートされ
              る。 O_EXCL サポートが提供されていない NFS 環境では、このフラグに頼って ロック処理を実
              行するプログラムは競合状態 (race condition) に出会う 可能性がある。 ロックファイルを使
              用して不可分  (atomic) なファイルロックを実現し、 NFS が O_EXCL をサポートしているかに
              依存しないようにしたい場合、  移植性のある方法は、同じファイルシステム上に他と名前の重
              ならない ファイル (例えばホスト名と PID を組み合わせた名前) を作成し、 link(2)  を使用
              してそのロックファイルへのリンクを作成することである。 link(2) コールの返り値が 0 なら
              ばロックに成功している。  あるいは、そのファイルに  stat(2)   を使用してリンク数 (link
              count) が 2 になっているかをチェックする。  そうなっていれば、同じくロックに成功してい
              るということである。
```

 今日では、Linux 2.6 以前を利用していることはまれであるだろうから、条件としては、「NFSv3 以降」でなければ O_EXCL は機能しないことの方が重要であろう。
 ここで NFSが O_EXCLをサポートしているかによらない方法（古典的なロック方法）が紹介されている。

## NFS のロックファイルルーチンを Windows へ持ってきた時の問題

 さて、問題は、UNIX環境ではこのファイルロックルーチンが機能する。しかしながら、Windows環境に持ってくると BasicFileAttributesの fileKey() は、null を返す。
 (単純に NTFS には、inode は無い）
```
ここで creationTime() による比較をしてはならない。lastAccessTime() も lastModifiedTime() も比較してはならない。
```

 
 Windowsにおいては、 GetFileInformationByHandle() を呼び出すときに使う
 第二引数 BY_HANDLE_FILE_INFORMATION 構造体の中にある nFileIndexHigh/nFileIndexLow の二つの数字の組みあわせが、
 ファイルシステムの中にあるファイルにあてがわれたユニークなID になる。Windows では VolumeSerialNumber との組み合わせで一意なファイルを識別できる。

 そして、Javaの実装を確認すると、java.nio.file.Files.isSameFile の実装が呼び出す sun.nio.fs.WindowsFileAttributes の isSameFile() が
 二つのファイルの同一性を確認するために、この volumeSerialNumber , fileIndexHigh , fileIndexLow の比較を行っている。

 ここで疑問が沸いてくる
- クリティカル区間は無いか？
- 一方(NTFS で ロックを取れていない方）がファイルを開いている間に 他方（ロックを取得した方）がファイルを delete できるか？




 
 
 